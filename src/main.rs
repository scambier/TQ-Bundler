mod config;
mod initializer;
mod module;
mod watcher;

use chrono::Local;
use clap::{App, Arg, ArgAction, ArgMatches, SubCommand};
use config::*;
use initializer::*;
use module::*;
use std::{
    env::current_dir,
    fs,
    path::PathBuf,
    process::{exit, Child, Command},
    sync::Mutex,
};
use watcher::watch;

fn main() {
    let matches = App::new("TIC-80 Bundler")
        .version("1.0.2")
        // RUN
        .subcommand(
            SubCommand::with_name("run")
            .about("Bundle and launch your game")
            .arg(
                Arg::new("GAME")
                    .help("The TIC game file, containing sounds and sprites, but no code")
                    .required(true)
                    .index(1),
            )
            .arg(
                Arg::new("CODE")
                    .help("The \"main\" code file that will be injected inside the game")
                    .required(true)
                    .index(2)
            )
            .arg(
                Arg::new("OUTPUT")
                    .short('o')
                    .long("output")
                    .help("The output bundle file. Defaults to \"build.[ext]\".")
                    .takes_value(true)
                    .required(false),
            )
            .arg(
              Arg::new("CLEAN")
                  .short('c')
                  .long("clean")
                  .help("Use this flag to remove comments generated by the bundler")
                  .action(ArgAction::SetTrue),
          )
            .arg(
                Arg::new("TIC")
                    .value_name("path")
                    .long("tic")
                    .help("Path to the TIC-80 executable. If specified, will launch TIC-80 in watch mode, with your game loaded.")
                    .takes_value(true)
                    .required(false),
            )
        )
        // INIT
        .subcommand(
            SubCommand::with_name("init").about("Initialize a TIC-80 project")
            .arg(
                Arg::new("LANG")
                    .required(true)
                    .index(1)
                    .help(r#""lua", "moon", "fennel", "wren", "squirrel", "js", "ruby", "janet"#)
            )
        )
        .get_matches();

    // Init project
    if let Some(initargs) = matches.subcommand_matches("init") {
        initialize(initargs.value_of("LANG").unwrap());
    }

    // Bundle, watch, run tic-80
    if let Some(runargs) = matches.subcommand_matches("run") {
        run(runargs);
    }
}

fn log(str: String) {
    println!("{:} - {:}", Local::now().format("%H:%m:%S"), str);
}
fn log_err(str: String) {
    eprintln!("{:} - {:}", Local::now().format("%H:%m:%S"), str);
}

fn compile(config: &Config) -> bool {
    println!("");
    let start_time = chrono::Local::now();

    // Load entry point module
    let mut path = PathBuf::from(&config.base_folder);
    path.push(&config.entry_point);
    path.set_extension(&config.filetype.extension);
    let main_module = match Module::new(&path, config) {
        Ok(module) => module,
        Err(_) => {
            log_err(format!("Could not find entry point file: {:?}", &path));
            return false;
        }
    };

    // List of files to include, starting with the entry file
    let mut modules: Vec<Module> = vec![main_module];
    // Modules to add once the loop is over
    let mut to_add: Vec<Module> = vec![];

    // Index all the modules
    let re_include = &config.filetype.regex;
    loop {
        modules.append(&mut to_add);

        for module in modules.to_vec().iter_mut() {
            // Find the include statements in the current module body
            for cap in re_include.captures_iter(&module.contents.clone()) {
                let name = cap.get(1).unwrap().as_str().to_string();
                let path = dotted_to_path(&name, config);

                if !Module::has_module(&modules, &path) {
                    // Module does not already exist, load it
                    let module = match Module::new(&path, config) {
                        Ok(module) => module,
                        Err(_) => {
                            log_err(format!("Could not find file: {:?}", &path));
                            return false;
                        }
                    };
                    to_add.push(module);
                }
            }
        }
        // Stop the indexing once we no longer have any module to add,
        if to_add.is_empty() {
            break;
        }
    }

    println!("Modules:");
    for module in modules.iter() {
        println!("{:?}", module.file_path);
    }
    println!("---");

    // Make a copy of the modules vec
    // to get a mutable copy of the entry file
    let mut modules_copy = modules.to_vec();
    let main_module = modules_copy.first_mut().unwrap();

    // Prefix with a small warning to not edit code
    main_module.contents = format!(
        "{comment}\n{comment} Bundle file\n{comment} Code changes will be overwritten\n{comment}\n\n{code}",
        comment=config.filetype.comment, code=main_module.contents
    );

    // Loop until all includes in the main file
    // are recursively replaced
    loop {
        let cloned_contents = main_module.contents.clone();
        match (
            re_include.captures(&cloned_contents),
            re_include.find(&cloned_contents),
        ) {
            (Some(cap), Some(pos)) => {
                let module_name = cap.get(1).unwrap().as_str().to_string();
                let path = dotted_to_path(&module_name, config);
                let mut module = modules
                    .iter_mut()
                    .find(|m| m.file_path == path)
                    .unwrap_or_else(|| {
                        panic!("Could not find module {:?} in the list of modules", &path)
                    });

                // Inject code into the main file
                if !module.injected {
                    let module_contents = if config.clean {
                        format!("{:}\n\n", &module.contents)
                    } else {
                        format!(
                            "{:} [TQ-Bundler: {:}]\n\n{:}\n\n{:} [/TQ-Bundler: {:}]\n\n",
                            &config.filetype.comment,
                            &module_name,
                            &module.contents,
                            &config.filetype.comment,
                            &module_name
                        )
                    };
                    // Inject the code
                    main_module
                        .contents
                        .replace_range(pos.range(), &module_contents);
                    module.injected = true;
                } else {
                    // Module code has already been injected, simply remove the include statement
                    main_module.contents.replace_range(pos.range(), "");
                }
            }
            _ => {
                // If we haven't captured any regex,
                // that means that all includes are resolved
                break;
            }
        }
    }

    // Log the (succesful or not) result
    let success = fs::write(
        config.base_folder.join(&config.output_file),
        &main_module.contents,
    );
    let elapsed = chrono::Local::now().signed_duration_since(start_time);
    match success {
        Ok(_) => {
            log(format!(
                "Compiled {:} files inside {:}, in {:}ms",
                modules.len(),
                &config.output_file,
                elapsed.num_milliseconds()
            ));
        }
        Err(e) => {
            println!("Could not write output file:");
            println!("{:?}", e);
        }
    };
    true
}

fn run(matches: &ArgMatches) {
    // Create a Config instance from the clap matches
    let config = Config::new(matches);

    // Initial compilation, if we don't want to watch the files
    let compiled = compile(&config);

    // If compilation failed AND we need to launch TIC, abort.
    // If subsequent compilations fail while TIC is already running,
    // we'll just log an error message and continue watching.
    if !compiled && config.tic_path.is_some() {
        println!("Compilation failed - Could not launch TIC-80");
        return;
    }

    // Start TIC-80
    let tic_path = config.tic_path.clone();
    let tic_process_mtx: Mutex<Option<Child>> = Mutex::new(None);
    if let Some(tic_path) = tic_path {
        let output_path = config
            .base_folder
            .join(&config.output_file)
            .to_str()
            .unwrap()
            .to_string();

        let cmds = [
            "--skip",
            "--keepcmd",
            &format!("--fs={}", current_dir().unwrap().to_string_lossy()),
            // format!("{}", config.game),
            "--cmd",
            &format!("load {} & load {} code & run", config.game, output_path),
        ];
        println!(
            "Starting TIC-80 with the following args:\n{:?}",
            cmds.join(" ")
        );

        let child = Command::new(tic_path)
            .args(cmds)
            .spawn()
            .expect("Failed to launch TIC-80");
        tic_process_mtx.lock().unwrap().replace(child);

        // Handle CTRL+C interruptions to exit gracefully
        let _handler = ctrlc::set_handler(move || {
            let child = tic_process_mtx.lock().unwrap().take();
            // Kill TIC-80 if it is launched
            if let Some(mut child) = child {
                let _ = child.kill();
            }
            exit(0);
        });
        // .expect("Error setting Ctrl-C handler");
    }

    // Start the watcher
    if config.tic_path.is_some() {
        println!("Watching...");
        if let Err(e) = watch(&config) {
            println!("error: {:?}", e)
        }
    }
}
